MoonWolf（むーんうるふ）です


DB関連のコンポーネントのセットアップをここにまとめます。

コンポーネントの場所はこちら、この順番で追加していけばよい。
DBGridが複数、Form1に含まれる場合、SQLQueryから先も複数準備する。詳細説明は後程。

SQLdb Tab -> TSQLite3Connection
SQLdb Tab -> TSQLTransaction
SQLdb Tab -> TSQLQuery
Data Access Tab -> TDataSource
Data Controls Tab -> TDBGrid
Data Controls Tab -> TDBNavigator

Form1に設置後
SQLite3Connection1
SQLTransaction1
SQLQuery1
DBGrid1
DBNavigator1


SQLite3Connection1
設置後、コードより
procedure TForm1.FormCreate(Sender: TObject);
begin
  SQLite3Connection1.DatabaseName := 'TEST01';
  SQLite3Connection1.Connected:=True;
end;       
これをコンパイル＋実行すると、LazarusはSQLite3.dllを認識うる。Connetionのインスペクターより接続のOnOffが可能となる。
※この接続が可能となった状態をどこで管理しているのかChatGPT4と一緒に探したものの、具体的には判明しなかった。

これでもNGな場合、Lazarusを再起動

接続が完成した場合：

SQLQueryにてSQLプロパティーを設定　　SELECT * FROM Student_Profies   ここにSQLの終わりの；を入れてはいけない。これではまる人もいる。

[1] しかし、TEXTのデータがすべて(MEMO)で表示　　－－＞解決：DBGrid Options　－＞ dgDisplayMemoText := True
[2] フィールド幅がすべて同じ　　　　　　　　　　 ーー＞解決：DBGrid Options  ー＞ dgAutoSizeColumns := Ture

これで、とりあえずテーブルのいい感じの表示は可能となる。

しかし、まだ、テーブルの更新ができない。DBNavigator上で操作しても、リフレッシュでエラーとなる。


ここの解決策が必要：
以下をついかするが、Database is locked とエラーとなる。
SQlite3は１ユーザーなので、オブジェクトインスペクターでの接続を切るとよくなる。（ここはテスト中）
※オブジェクトインスペクターより実行中に切断するとAccess violation,  設計時に切断すると今度は実行時に表示しないー＞要解決

オブジェクトインスペクター経由でフォームデザイナーに表示するのは、表示だけならばよいがUpdate、などの変更があるとNG

それを解決するために、Form1の onCreate にてSQL文の内容は表示させる

// SQLクエリを設定してオープン
  SQLQuery1.SQL.Text := 'SELECT * FROM student_profiles';
  SQLQuery1.Open;      

そして、オブジェクトインスペクターとDBの接続を切る。実行中に切ると、Access Violation.
実行を止めてから、接続を切ること。Connectionを着ると、Transaction,Queryともに自動で切れる。

その状態：
１、OnCreateでDBのQuery内容はDBGridに表示している
２、オブジェクトインスペクターをつかったフォームへの表示を切断

これらの上で、以下のAfterPostのProcedureを実行すると、DBが見事にDBGridとDBNavigatorでフィールドが更新される
AfterPostでは、フィールドの更新、レコードの追加には対応できるが、レコードの削除には対応していない

procedure TForm1.SQLQuery1AfterPost(DataSet: TDataSet);
begin
  // 変更を適用
  try
    SQLQuery1.ApplyUpdates;  // 変更をデータベースに適用
    SQLTransaction1.CommitRetaining;  // トランザクションをコミットして再利用可能に
  except
    on E: Exception do
    begin
      ShowMessage('Error updating record: ' + E.Message);
      SQLTransaction1.RollbackRetaining;  // エラー時にロールバック
    end;
  end;
end;                  

Lazarus DBは実に慎重につくられている、DBNAVIを使ったレコードの削除にはAfterDeleteが必要

procedure TForm1.SQLQuery1AfterPost(DataSet: TDataSet);
begin
  // 変更を適用
  try
    SQLQuery1.ApplyUpdates;  // 変更をデータベースに適用
    SQLTransaction1.CommitRetaining;  // トランザクションをコミットして再利用可能に
  except
    on E: Exception do
    begin
      ShowMessage('Error updating record: ' + E.Message);
      SQLTransaction1.RollbackRetaining;  // エラー時にロールバック
    end;
  end;
end;                   

ここまではテストOK!　2024.10.18
